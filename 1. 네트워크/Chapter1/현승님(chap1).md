# Chapter01

[toc]

## 0. 흐름

### 1. 웹 브라우저

1. URL을 브라우저에 입력한다.
2. 브라우저에서 URL에 따른 리퀘스트 메시지(HTTP)를 만들어 소켓에 건네준다.
3. 소켓은 받은 HTTP 메시지를 송신 데이터로 프로토콜 스택에 건네준다.

### 2. 프로토콜 스택(TCP/IP), LAN 어댑터

1. TCP는 송신 데이터를 패킷의 길이에 맞게 분할하고, TCP헤더를 부가하여 IP에 건내준다.
2. IP는 패킷에 IP헤더를 부가하고, MAC 주소를 조사하여 MAC 헤더도 부가하여 LAN 드라이버에 건네준다.
3. LAN 어댑터는 이더넷이 송신 가능한 상태가 되면 패킷을 전기신호로 변환하여 트위스트 페어 케이블에 보낸다.

### 3. 허브, 스위치, 라우터

1. 트위스트 페어 케이블 -> 리피터 허브 -> 스위칭 허브로 신호가 도달한다.
2. 스위칭 허브는 패킷의 수신자 MAC 주소와 자신의 주소테이블을 대조하여 출력 포트에 패킷을 중계한다.

3. 라우터는 도착한 패킷의 수신자 IP주소와 라우팅 테이블을 대조하여 출력 포트에 패킷을 중계한다.
4. 라우터가 인터넷에 출력한 패킷에는 PPPoE 헤더와 PPP 헤더가 붙어있다.(?)

### 4. 액세스 회선, 프로바이더

1. 인터넷의 입구에는 엑세스 회선이라는 통신 회선이 있다.(ISDN, ADSL, CATV, FTTH)
2. 액세스 회선은 계약하고 있는 프로바이더에 연결되어 있으며, 여기에 POP라는 설비가 있다.
3. POP는 통신사용 라우터로, 가장 가까운 우체국 개념으로 생각하면 된다.
4. POP에서 패킷이 전 세계 곳곳으로 전송되기 때문에 인터넷의 핵심부라고 할 수 있다.
5. 패킷 운반 기술 등 오늘날 네트워크 기술의 최첨단이 여기에 집중되어 있다.

### 5. 방화벽, 캐시 서버

1. 패킷이 최종적으로 서버 측 LAN에 도착하면, 방화벽에서 패킷을 검사한다.
2. 데이터 중 재사용할 수 있는 것들은 캐시서버에 들어간다.
3. 캐시서버를 통해 재사용 데이터는 웹서버에 의뢰하지 않고 캐시서버에서 바로 읽을 수 있다.
4.  대규모 웹사이트라면 복수의 웹서버에 메시지를 분배하는 부하 분산 장치가 있다.

### 6. 웹 서버

1. 패킷이 웹 서버에 도착하면 프로토콜 스택이 패킷에서 원래 리퀘스트 메시지를 추출하고 서버 어플리케이션에 넘긴다.
2. 어플리케이션이 메시지를 읽고 그에 대한 응답 메시지를 만든다.
3. 프로토콜 스택에서 응답 메시지를 패킷에 저장하고, 클라이언트에게 전송한다.



## 1. HTTP 리퀘스트 메시지를 작성한다.

### URL의 구조

> ex) http://www.ssodam.com/content/1100987?prev=2&prev_content=/board/5

#### http: 

- 데이터 출처에 액세스하는 방법/프로토콜

#### //

- 이어지는 문자열이 서버의 도메인 이름을 나타냄

#### /content/1100987

- content라는 디렉토리의 1100987파일이라는 경로명을 나타냄

#### prev=2&prev_content=/board/5

- 옵션을 나타냄, 보충 정보



### HTTP의 기본 개념

> HTTP 프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것

리퀘스트 메시지는 `URI`와 `메소드`로 이루어져 있다. 웹에서는 HTTP 프로토콜 방식대로 리퀘스트 메시지를 구성하게 된다.

#### `URI`

- 보통 페이지 데이터를 저장한 파일의 이름이나 CGI 프로그램의 파일명을 쓴다.
- ex) /dir/file1.html

#### `메소드`

- 웹 서버에 어떤 동작을 하고 싶은지를 전달한다.

- 대표적으로, URL로 나타낸 데이터를 읽는 `GET`메소드, 클라이언트에서 입력한 데이터를 URI로 나타낸 프로그램에 전달하는 `POST`메소드가 있다.

  1. 리퀘스트 메시지의 메소드에 `GET` 이라고 쓰고, URI에는 `/dir/file1.html`와 같이 페이지의 데이터를 저장한 파일의 이름을 쓴다. 이 리퀘스트 메시지가 웹서버에 도착하면, 서버는 파일을 열고 내용의 데이터를 추출해서 응답 메시지에 담아 클라이언트에 반송한다.
  2.  `POST`메소드는 `폼`에 데이터를 사용해서 웹 서버에 송신하는 경우에 사용한다. 리퀘스트 메시지 안에는 `URI`, `메소드`와 더불어 `CGI 프로그램`이나 스크립트에 건네주는 데이터도 쓴다.

- 어떤 메소드를 쓸것인가?

  답은 브라우저의 동작 상태에 있다.

  - URL 입력상자에 URL을 입력하여 해당 페이지를 표시할 때
  - 하이퍼링크를 클릭할 때
  - 폼에 데이터를 기입하여 송신 버튼을 누를 때 

#### `Status code`

- 웹 서버 응답메시지의 맨 앞부분에 있으며, 리퀘스트 메시지에 대한 실행 결과가 정상 종료되었는지를 나타낸다.

- `404 Not Found`와 같이 표시될 수 있다. 이 응답 메시지를 클라이언트에 반송한다.



### HTTP 메시지의 포맷

#### 리퀘스트 메시지
- `Request Line`
  - 리퀘스트 메시지의 첫 번째 행에 쓴다.
  - `메소드`<공백> `URI`<공백>`HTTP 버전`
- `메시지 헤더`
  - <헤더필드명>:<필드값>
  - <공백 행>
-  `메시지 본문`
- 클라이언트에서 서버에 송신하는 데이터, `폼`페이지에 입력한 데이터를 `POST`메소드로 웹 서버에 보낼 때 등의 데이터가 들어간다.

#### 응답 메시지

- `Status Line`
- `HTTP 버전`<공백>`Status Code`<공백>`응답 문구`
  
- `메시지 헤더`

  - <헤더필드명>:<필드값>
  - <공백 행>

- `메시지 본문`

  - 서버에서 클라이언트에 송신하는 데이터, URI가 가리키는 파일에서 읽은 데이터, CGI어플리케이션이 출력한 데이터가 들어간다.

---

#### 헤더 필드의 종류

- 응답 헤더 : 응답의 부가 정보로 사용되는 헤더 필드
  - `Location`, `Server`, `WWW-Authenticate`, `Accept-Ranges`
- 엔티티 헤더 : 메시지 본문의 부가 정보로 사용되는 헤더 필드
  - `Allow`, `Content-Encoding`, `Content-Length`, `Content-Type`, `Expires`, `Last-Modified`, `Content-Language`, `Content-Location`, `Content-Range`, `Etag`



## 2. 웹 서버의 IP주소를 DNS 서버에 조회한다

### TCP/IP의 기본 개념

- 작은 서브넷을 라우터로 접속하여 전체 네트워크를 완성한다.

### IP주소의 구성

- IP 주소는 32비트로 구성되어 있으며, 네트워크 번호와 호스트 번호가 합쳐진 형태이다.
- `10.11.12.13`과 같이 8비트씩 점마다 구분하여 표기한다.
- 네트워크 번호와 호스트 번호를 구분하기 위해서는 `넷마스크`가 필요하다.
- `넷마스크`는 IP주소에서 32비트 부분의 디지털 데이터이다.
- `넷마스크`를 비트로 변환했을때 1인 부분이 네트워크 번호이고, 0인 부분이 호스트 번호이다.
- `255.255.255.0`
- 호스트 번호가 모두 0이면 서브넷 자체를 나타낸다.
- 호스트 번호가 모두 1이면 서브넷에 있는 기기 전체에 패킷을 보내는 `브로드캐스트`를 나타낸다.

### 도메인명과 IP주소를 구분하여 사용하는 이유

- IP주소는 32비트, 즉 4바이트 밖에 없지만 도메인명은 수십 수백 바이트를 차지함.
- 그만큼 라우터가 부하되어 데이터 전송에 더 많은 시간이 걸림.

### 브라우저는 어떤 원리로 DNS 서버를 조회하는 것일까?

#### 리졸버

- socket 라이브러리에 들어있는 부품화한 프로그램

- DNS 서버에 대한 DNS 클라이언트의 역할을 한다.

- IP 주소를 조사하는 네임 리졸루션을 실행하는 것이 **리졸버**이다.



## 3. 전 세계의 DNS 서버가 연대한다.

### DNS 서버의 동작

> 기본 동작 : 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답

- 조회 메시지 : 이름, 클래스, 타입
- 도메인 계층 구조
  - ex) www.cyber.co.kr
  - 최상위: kr -> 대한민국에 할당된 도메인
  - co -> 국내의 도메인 분류를 위한 도메인
  - cyber -> 회사에 할당된 도메인
  - 최하위: www -> 서버이름
- 액세스 대상의 웹 서버가 어느 DNS 서버에 등록되어 있는 지 찾아내는 방법
  1. 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위 DNS 서버에 등록합니다.
  2. 상위의 DNS 서버의 IP를 또 그 상위의 DNS 서버에 등록
  3. 즉, lab.glasscom.com -> glasscom.com DNS서버에 등록 -> com DNS서버에 등록
  4. 이렇게 하면 상위의 DNS서버에 가면 하위의 DNS서버도 알 수 있다.



## 4. 프로토콜 스택에 메시지 송신을 의뢰한다.

> IP주소 조사 후 액세스 대상(웹 서버)에 데이터를 송신하기 전에 OS 내부의 프로토콜 스택에 의뢰해야 한다.

**개념도**

![img](1%네트워크.assets/img.png)

**Socket 라이브러리**

- Socket 라이브러리는 클라이언트와 프로토콜 스택의 중개역할을 한다.
- 즉, 클라이언트에서 프로토콜 스택으로 메시지 송수싲을 의뢰할 때는 Socket 라이브러리를 거쳐야한다.



**Socket**

![img](1%네트워크.assets/Untitled (7).png)

​											< 메시지 송 수신 과정을 나타낸 소켓 다이어그램 >



- 소켓은 클라이언트와 서버 간 데이터를 송수신할 수 있는 출입구 역할을 한다.
- 프로토콜 스택에 송신동작을 의뢰하면, 소켓을 통해 클라이언트와 서버 간 출입구를 만들고 서로 연결한다.



**메시지 송 수신 과정**

  1. 소켓 작성
  2. 서버의 소켓과 연결(접속)
  3. 데이터 송, 수신
  4. 소켓 말소



1. 소켓 작성 단계

> 자세한 내용은 2장에서 작성

(1) 소켓을 호출하고, 각 소켓의 식별자 역할을 하는 디스크립터를 받아 기록해 두는 단계이다.



2.  접속 단계

(1) 소켓 라이브러리의 `connect` 함수를 사용하여 접속을 실행한다.

(2) `connect` 에 필요한 인자로는 디스크립터, 서버의 IP주소, 포트번호 세 가지가 필요하다.

(3) 디스크립터는 클라이언트 내부에서 소켓을 식별하기 위한 용도이며, 접속 상대측에서는 포트번호를 통해 소켓을 식별한다.



3. 데이터 송 수신

(1) `write` 를 사용한다.



4. 연결 끊기

(1) `close`를 사용하면, 연결이 끊어지고 소켓 또한 말소된다.





