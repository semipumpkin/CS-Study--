# Chapter 01

## 1.

- **브라우저:**

  - URL을 해독하거나 HTTP 메시지를 만들지만,
  - 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의하여 송신

  

- **URL(Uniform Request Locator):** 

  - http, ftp 등등이 있다.
  - 맨 앞에 엑세스하는 방법이 적혀있음
  - 맨 앞의 프로토콜에 따라 뒤에 쓰는 방법이 달라짐
  - http://edu.ssafy.com/edu/main/index.do 의 경우
    - 1. http: -> 프로토콜 종류
      2. //: -> 나중에 이어지는 문자열이 서버의 이름임을 나타냄
      3. edu.ssafy.com: -> 웹 서버명
      4. /edu/main/: -> 디렉토리 경로
      5. index.do: -> 파일
    - 파일명은 생략 가능하다!
    
    

- **프로토콜: 동작의 규칙을 정한 것을 '프로토콜'이라고 부름**

  - 웹 서버라면 HTTP 프로토콜
  - FTP 서버 FTP 프로토콜

  

- **HTTP(Hyper Text Transfer Protocol):**

  > 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것

  - 클라이언트 -> 서버: 리퀘스트 메시지
  - 서버 -> 클라이언트: 응답 메시지
  - HTTP 메시지를 만들면 이것을 OS에 의뢰하여 엑세스 대상의 웹 서버에게 송신

  

- **request message:**

  > 무엇 + 어떻게 해서 => 서버에 요구를 함

  - 무엇: 데이터를 저장한 파일 이름 or CGI 프로그램의 파일명
  - 어떻게 해서: 매서드(우리가 배운 GET, POST ...)

  

- **response message:**

  > 응답 메시지 = 스테이터스 코드 + 헤더 파일 + 페이지의 데이터

  - reqeust message를 서버가 해독 -> 응답 메시지를 클라이언트에 전송
  - 맨 앞부분에는 스테이터스 코드가 있음(200, 404, 405, 504 etc...) -> '404 Not Found'

  

- **메소드:**

  - 웹 사이트에 어떤 동작을 하고싶은지 전달
  - `GET`: URI로 지정한 정보를 도출
  - `POST`: 폼에 입력한 데이터를 송신하는경우 사용
  - `PUT`: URI로 지정한 서버의 파일을 치환(변경?), 지정한 파일이 없는 경우에 새로 파일을 작성
  - `DELETE`: URI로 지정한 파일을 삭제



- **리퀘스트 메시지 작성:**

  1. 첫 번째 행에 있는 리퀘스트 라인: 맨 앞에 메소드가 적힘
  2. (한칸 띄고) URI: 파일이나 프로그램 경로명
  3. 두 번째 행: 메시지 헤더 행 -> 리퀘트의 내용 이외에 부가적인 자세한 정보가 필요한 경우 이것을 메시지 헤더에 써둠
  4. (아무것도 쓰지 않은 하나의 공백) 메시지 본문: 송신할 데이터를 씀

  

- **스테이터스 코드:**

  | 코드값 | 설명                      | ex|
  | ------ | ------------------------- |-----------------------|
  | 1xx    | 처리의 경과 상황등을 통지 |`100 Continue`: 지금까지의 상태가 괜찮으며 클라이언트가 계속해서 요청을 하거나 이미 요청을 완료한 경우에는 무시해도 됨|
  |2xx | 정상 종료|`200 OK`: 요청이 성공적으로 되었음|
  |3xx | 무언가 다른 조치가 필요함|`302 Found`: 요청한 리소스의 URI가 일시적으로 변경되었음을 의미|
  |4xx | 클라이언트측의 오류 |`403 Forbidden`: 클라이언트가 콘텐츠에 접근할 권리를 가지고 있지 않음|
  |5xx| 서버측의 오류|'502 Bad Gateway': 서버가 요청을 처리하는 데 필요한 응답을 얻기 위해 게이트웨이로 작업하는 동안 잘못된 응답을 수신했음|




## 2.

- **도메인**: 인터넷창에 치는 주소



- **IP 주소:**

  > 네트워크 번호(서브넷 번호) + 호스트 번호

  - OS에서는 송신할때 도메인명이 아니라 IP주소로 메시지를 받을 상대를 지정

  - 서버까지 메시지를 운반할 때는 이 IP 주소에 따라 운반

  - 데이터는 패킷 형태로 운반됨

  - 오늘날 주로 사용되고 있는 IP 주소는 IP 버전 4([IPv4](https://ko.wikipedia.org/wiki/IPv4)) 주소이나 이 주소가 부족해짐에 따라 길이를 늘린 IP 버전 6([IPv6](https://ko.wikipedia.org/wiki/IPv6)) 주소가 점점 널리 사용되는 추세이다.

  - IPV4 = 32bit, 각 비트를 `.`으로 구분하여 사용

  - IPV6 = 128 bit, 각 비트를 `:`으로 구분하여 사용

  - IPV4에서...

    - 8bit씩 점으로 구분하여 10진수로 표기 => `192.168.0.5`

  - 넷마스크: 네트워크 번호와 호스트 번호를 구분해주기 위해 덧붙히는 값 => `255.255.255.0`

    - 1인 부분은 네트워크 번호, 0인 부분은 호스트 번호 => 1인부분인 `192.168.0`은 네트워크 번호, 0인 `5`는 호스트 번호

    

- **도메인명과 IP주소를 구분하여 사용하는 이유:**

  > 실제 데이터를 주고받을떄는 IP주소를 사용하지만 IP주소를 그냥 사용하기에는 기억하기 어렵기 떄문에
  >
  > 도메인명을 사용하여 IP주소를 받아온다

  - DNS에 도메인명을 의뢰하면 IP주소를 반환해줌



- **DNS(Domain Name System):**

  - DNS서버에 조회한다 => DNS 서버에 조회 메시지를 보내고, 거기에서 반환되는 응답 메시지를 받는다. 즉 DNS 서버에 대해 클라이언트로 동작한다.

  - 리졸버 = DNS 클라이언트

    > 도메인명에서 IP주소를 조사할 때 브라우저는 Socket 라이브러리의 리졸버를 이용

    - 리졸버를 네트워크 애플리케이션에서 호출하면 리졸버가 DNS 서버에 조회 메시지를 보내고, DNS 서버에서 응답 메시지가 돌아옴
    - 이 응답 메시지 속에 IP 주소가 포함되어 있음. 리졸버는 이것을 추출하여 브라우저에서 지정한 메모리 영역에 써넣음

  - 네임 리졸루션: DNS를 사용하여 IP주소를 조사하는것

  - DNS서버의 IP 주소는 OS에서 TCP/IP를 설정할때 미리 설정해둠



- **IP주소를 조사하는 방법:**
  1. 애플리케이션 프로그램(웹 브라우저)
  2. Socket 리졸버를 호출하여 도메인 명을 넘겨줌
  3. 리졸버가 DNS서버로 조회 요청을 보냄
  4. DNS서버에서 조회 후 IP주소를 응답으로 보냄
  5. 리졸버가 응답 내용을 해독하고 IP주소를 추출 및 어플리케이션에게 전달
  6. 어플리케이션 프로그램은 메모리 영역에 해당 IP주소를 저장



- **socket 라이브러리:**
  - OS에 포함되어 있는 네트워크의 기능을 애필리케이션에서 호출하기 위한 라이브러리



- 라우터 -> 3장에서
- 허브 -> 3장에서
- 포트번호 



## 3.

3은 읽어도 이해가 안가네여 ㅠ...

## 4.

- **데이터 송 수신 과정:**

  - 서버측에서 소켓을 만들고, 소켓에 클라이언트가 연결하기를 기다림

  - 클라이언트 측에서도 소켓을 만들고

    1. DNS서버에 IP주소 조회를 보낼때 처럼, Socket 라이브러리의 프로그램 부품을 호출함

    2. 소켓 라이브러리의 socket이라는 프로그램을 호출

    3. socket 프로그램으로 제어가 넘어가서 소켓을 만듬

    4. 소켓이 생기면 디스크립터가 생기며 애플리케이션은 이것을 받아서 메모리에 기록해 둠

  -  서버측의 소켓에 연결

    1. Socket 라이브러리의 connect라는 프로그램 부품을 호출하여 서버측의 소켓에 접속

    2. connect를 호출할 때 지정하는 값은 디스크립터, 서버의 IP주소, 포트 번호

    3. 디스크립터로 어느 소켓을 서버측의 소켓에 접속할 것인지, 서버 IP주소로 접속하려는 서버는 어떤것인지, 포트 번호로 서버의 어느 소켓에 접속할 것인지를 지정할 수 있음

       -> 즉 디스크립터로 내 소켓중 어느 소켓이 ip주소 + 포트 번호로 어느 서버의 어느 소켓에 접속할것인지 지정

  - 연결이 되었으니 메시지를 주고

    1. Socket 라이브러리의 wirte라는 프로그램을 사용 -> write를 호출할 때 디스크립터와 송신데이터를 지정
    2. 사용자가 입력한 URL을 바탕으로 HTTP 리퀘스트(송신 데이터)를 생성
    3. write의 디스크립터로 데이터를 보내서 서버로 데이터를 보냄

  - 응답을 받음

    1. Socket의 read라는 프로그램을 사용
    2. 수신할 응답 메시지를 저장하기 위한 메모리 영역인 `수신 버퍼`에 read 프로그램이 응답을 받아서 저장
    3. 수신버퍼에 저장된 메시지를 어플리케이션에 전달

  - 통신이 끝나면 서버 혹은 클라이언트 어느쪽에서라도 연결을 끊으면 됨

    1. Socket 라이브러리의 close라는 프로그램 부품을 호출하여 연결 끊기 단계로 들어감
    2. 소켓 사이의 연결이 말소되고 소켓도 말소

  - 연결이 끊기면 소켓이 말소하며 통신이 종료



- 소켓:

  > 데이터를 송수신하기 위해서는 데이터의 출입구를 만들어야하는데 이 출입구를 `소켓`이라고 부름

- 디스크립터:

  > 복수의 소켓이 컴퓨터에 존재할경우 하나하나의 소켓을 식별하기 위한것(하나하나의 소켓에 할당한 번호표)



