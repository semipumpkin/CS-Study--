# Chapter 06

## 01. 서버의 개요

### 1. 클라이언트와 서버의 차이점

클라이언트와 서버의 네트워크 부분, 즉 LAN어댑터, 프로토콜 스택, Socket 라이브러리 등의 본래 기능은 완전히 동일하다. 그렇다면 둘의 차이는 무엇인가?

(1) 개념적 차이

- 클라이언트: 서버에게 서비스를 요청하고, 받은 응답을 사용자에게 표현하는 시스템
- 서버 : 클라이언트의 요청에대한 서비스(응답)을 제공하는 컴퓨터 시스템

(2) 구조적 차이

- 클라이언트 : 한 번에 하나의 서버에 요청을 보낸다.

- 서버 : 동시에 다수의 클라이언트 PC에 응답하는 구조

- 이러한 차이로 인해 소켓의 접속 동작에서 차이를 보인다.

  - 클라이언트는 소켓 접속동작을 하고, 서버는 접속대기 역할을 한다.
  - 더 구체적으로는 Socket 라이브러리를 호출하는 과정에 차이가 있다.
  - `bind` : 소켓에 포트번호 기록(클라이언트에서 지정한 서버측 소켓에 할당할 포트번호)
  - `listen`: 접속 대기상태라는 제어 정보를 기록하는 용도
  - `accept`: 접속 접수(실제 접속 기다리는 상태)




#### 멀티태스크 & 멀티쓰레드

- 접속 패킷이 동작했을 때 새 소켓을 복사하여 접속한다.
- 원래 소켓은 계속 접속 대기상태로 두어 동시에 다수의 클라이언트와 접속할 수 있게 된다.

- 멀티태스크와 멀티쓰레드는 동시에 복수의 액세스를 병행하여 처리하는 OS의 기능을 말한다.
- 태스크는 하나하나 별도의 프로그램을 의미하며, 쓰레드는 한 개의 프로그램을 몇 개의 부분으로 나눈 것으로 취급된다.



:question: 새 소켓을 만들 때의 포트 번호를 어떻게 해야 할까

1. 복사하는 포트번호를 다르게 한다면?

   - 클라이언트에서 지정한 포트 번호로 소켓을 보냈을 때 돌아오는 소켓의 포트 번호는 다르게 된다. -> 회답이 올바른 상대로부터 왔는지, 다른 상대로부터 왔는 지 알 수 없게 된다.

2. 복사하는 포트번호를 같게 한다면?

   - 같은 포트번호를 가진 소켓이 여러 개 존재해서 포트번호로 소켓을 식별할 수 없게 된다.
   - 이 문제를 해결하기 위해 추가로 네 가지의 정보를 더 사용하여 소켓을 식별한다.
     1. 클라이언트측 IP주소
     2. 클라이언트측 포트 번호
     3. 서버측 IP주소
     4. 서버측 포트 번호

   :question: 그럼 디스크립터는 왜 필요하지?

   - 접속 대기 상태의 소켓에는 아직 클라이언트 측의 IP주소와 포트번호가 기록되어 있지 않기 때문이다.
   - 따라서 접속 대기 이전 상태에서는 디스크립터가 필요하며 한 가지 정보만으로 식별할 수 있다는 간편함도 있다.



## 02. 서버의 수신 동작

### (1). LAN 어댑터의 동작

1. LAN어댑터의 MAC 부분이 패킷을 신호에서 디지털데이터로 변환
2. FCS(프레임 체크 시퀀스)를 통해 패킷 오류 검사
3. LAN어댑터의 버퍼메모리에 저장하고 CPU에 패킷도착 알림
4. CPU -> LAN 드라이버 실행 -> MAC 헤더로부터 프로토콜을 판단하여 프로토콜 스택을 호출하여 패킷을 건네줌

### (2) IP 담당 부분의 동작

1. 자신을 대상으로 한 것인지 판단
2. 조각 나누기에 의한 패킷의 분할이 있는 지 조사
3. TCP(UDP) 담당 부분에 패킷을 건네줌

### (3) TCP 담당 부분의 접속 대기상태에서의 동작

1. TCP 헤더의 SYN의 컨트롤 비트를 확인
2. 수신처 포트 번호 조사
3. 해당 접속 대기 소켓을 복사
4. 송신처의 IP주소나 포트 번호를 기록

### (4) TCP 담당 부분의 데이터 패킷 수신 시 동작

1. 도착한 패킷의 소켓 식별을 위한 4가지 요소를 통한 소켓 판단
   - 클라이언트측 IP주소, 클라이언트측 포트 번호, 서버측 IP주소, 서버측 포트 번호
2. 데이터 조각을 연결하여 수신 버퍼에 보관
3. 클라이언트에게 ACK 회답



### (5) TCP 담당 부분의 연결 끊기 동작

- 클라이언트 측과 동일





## 03. 서버가 요청에 응답하는 과정

> 패킷 수신 후 요청의 리퀘스트 내용을 처리하는 과정

- 웹 서버의 경우, HTTP request를 받는다.
- HTTP method나, URI에 따라 웹 서버가 요청한 대로 동작한다.



**CGI**

- Common Gateway Interface
- 웹 서버상에서 사용자요청 프로그램을 동작시키기 위한 인터페이스



**액세스 제어**

웹서버에서는 주로 세 가지 조건을 통해 클라이언트의 접근을 제한한다.

1. 클라이언트의 IP주소
   - 소켓 접속 접수시 클라이언트 IP주소를  알 수 있으므로 점검한다.
2. 클라이언트의 도메인
   - 클라이언트 IP주소에 대응하는 도메인을 찾기위해 가장 가까운 DNS서버에 메시지를 보낸다.
   - DNS서버는 IP주소가 등록된 DNS서버를 찾아 대응하는 도메인 명을 회답받는다.
   - 웹 서버는 IP주소를 통해 얻은 도메인명과 도메인명에서 조사한 IP주소와 클라이언트 IP주소를 비교하여 이중으로 점검한다.
   - DNS 서버 조회 메시지가 왕래하는 만큼 웹 서버의 응답시간이 오래 걸린다.
3. 사용자명과 패스워드
   - 



## 04. 웹 브라우저가 응답을 받아 렌더하는 과정



### 클라이언트에서 응답 데이터의 종류를 판단하는 방법

1. 응답 메시지의 헤더필드 `Content-Type`을 통해 판단

	- ex) text/html      (주타입, 분류)/(서브타입, 실제 데이터 타입)
	- 만약 서버에서 Content-Type을 정확하게 설정하지 않은 경우 문제가 생길 수 있다.

2. 요청 파일의 확장자나 포맷 등에서 종합적으로 판단
   - 예를 들어 조사한 파일의 확장자가 html인 경우 데이터 내용을 조사하여 <html> 태그가 앞에 있으면 HTML문서로 간주하는 형식



