[toc]



# Chapter02. TCP/IP의 데이터를 전기신호로 만들어 보낸다 - 프로토콜 스택과 LAN어댑터의 탐험

## 주요용어 정리

### 1. OSI 7 계층

- 국제 표준 기구인 ISO 에서 제시한 네트워크 모델입니다.
- 하위계층에는 물리 계층, 데이터 링크 계층, 네트워크 계층이 있습니다.
- 상위계층에는 전송계층, 세션계층, 표현계층, 응용 게층이 있습니다.

### 2. TCP / IP 4계층

### 3. 프로토콜

- 서로 다른 기기들 간의 데이터 교환을 위해 표준화한 통신 규약입니다.
- 프로토콜의 기능에는 흐름제어, 오류제어, 순서제어 등이 있습니다.
- **흐름제어** 는 수신측에서 송신측이 송신하는 데이터의 전송량이나 전송 속도를 조절하는 기능입니다. 이 때, 정지 대기 방식과 슬라이딩 윈도우 방식을 사용합니다.
- **오류제어** 는 전송중에 발생하는 오류를 검출하고 정정하여 정보의 파손에 대비하는 기능입니다.
- **순서제어** 는 데이터 블록에 전송 순서를 부여하는 기능입니다. 송신 데이터들이 순서적으로 전송되도록 함으로써 흐름제어 및 오류제어를 용이하게 합니다.
- **혼잡제어** 는 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것입니다. 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막습니다.

### 4. 소켓

### 5. 패킷

### 6. 3-way handshake와 4-way handshake



### 7. TCP / UDP의 차이점





## Story 01.소켓을 작성한다.

### 1-1. 프로토콜 스택의 내부구성

#### OSI 7계층

![img](https://camo.githubusercontent.com/abb5beca5cd3003722a4a9bf8dd3b173183f60d51fbbe8bf282b7efd11afbb39/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d6874747073253341253246253246626c6f672e6b616b616f63646e2e6e6574253246646e2532466272474779752532466274717a6963306f3754652532467a434c516b3161715135786b3572337656686c4a6e4b253246696d672e706e67)

- **1. 물리 계층** 은 상위 계층에서 전송된 데이터를 물리매체를 통해 다른 시스템에 전기적 신호로 전송합니다.
- **2. 데이터링크 계층** 은 네트워크 계층에서 받은 데이터를 프레임 단위로 구성하여 물리 계층으로 전송합니다. 포인트 투 포인트(Point to Point) 간 신뢰성있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요합니다. 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻입니다.
- **3. 네트워크 계층** 은 라우팅 프로토콜을 이용해서 최적의 경로 선택합니다. 라우팅, 흐름 제어, 오류 제어 등을 수행합니다. 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적(hierarchical)입니다.
- **4. 전송 계층** 은 균일한 데이터 전송 서비스를 제공하는 계층입니다. 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해줍니다. 시퀀스 넘버 기반의 오류 제어 방식을 사용합니다.
- **5. 세션 계층** 은 송 수신 간의 관련성을 유지하고 대화 제어를 담당합니다. 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공합니다. 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행합니다. 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 가집니다.
- **6. 표현 계층** 은 서로 다른 환경의 Application들이 데이터를 이해할 수 있도록 도와주는 계층입니다. 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 줍니다. MIME 인코딩, JPEG 및 GIF 포맷, 암호화 등의 동작이 이 계층에서 이루어집니다.
- **7. 응용 계층** 은 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공합니다.

#### TCP / IP 4계층

- OSI 7계층 기반하여 실무적으로 이용될 수 있도록 단순화된 모형
  - TCP : 전송 제어 프로토콜로 전송 계층에 위치하며 네트워크 정보 전달을 통제하는 핵심 프로토콜
  - IP : 패킷 교환 네트워크에서 정보를 주고받는데 사용하는 정보 위주의 규약이며 네트워크 계층에서 호스트의 주소지정과 패킷 분할 및 조립 기능을 담당

![image](https://user-images.githubusercontent.com/36289638/105438345-2630f000-5ca6-11eb-87be-63b558b8416a.png)

- 네트워크 계층(Network Layer)
  - MAC 주소를 참조해 장비 간 데이터 송수신
  - 브리지, 스위치
- 인터넷 계층(Internet Layer)
  - 데이터 전송을 위한 IP 주소 지정 및 경로 지정
  - 라우터
- 전송 계층(Transport Layer)
  - Port 번호로 호스트 간의 연결 제어 및 자료 송수신
  - 게이트 웨이
- 응용 계층(Application Layer)
  - 응용프로그램 간의 데이터 송수신
  - 사용자 응용 프로그램 인터페이스

### 1-2. 소켓의 실체는 통신 제어용 제어 정보

- 네트워크상에서 동작하는 프로그램 간 통신**의** 종착점(Endpoint)입니다. 즉, 프로그램이 네트워크에서 데이터를 통신할 수 있도록 연결해주는 연결부라고 할 수 있습니다.
- 소켓은 통신을 위한 일종의 통로

- IP, 포트번호 등의 제어 정보를 기록한 프로토콜 스택의 메모리 영역

### 1-3. Socket을 호출했을 때의 동작

- 브라우저가 socket부품을 호출하게 되면 프로토콜 스택은 한개의 소켓을 만듬
- 프로토콜 스택은 소켓 한개 분량의 메모리 영역 확보 후, 제어 정보를 기록.
- 메모리 영역에 제어 정보를 넣은 것이 소켓이 만들어지는 것.

## Story 02. 서버에 접속한다

### 2-1. 접속의 의미

- 클라이언트와 서버 간 제어 정보, 즉 IP와 포트 번호 등을 주고 받는 것. 
- 클라이언트와 서버는 각자의 소켓에 해당 제어 정보를 저장함으로써 데이터 송/수신 상태가 되고, 데이터 송/수신 동작을 실행할 때는 송/수신 데이터를 임시로 저장할 **버퍼 메모리**를 확보 

### 2-2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

- 제어 정보는 크게 두 종류

  1. 헤더에 기입되는 정보와 소켓에 기록되는 정보
  2. 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보

  

### 2-3. 접속 동작의 실제

![img](https://github.com/ambosing/PlayGround/blob/master/Img/Network/Message%20Send%20Action.jpg?raw=true)

1. 소켓을 만드는 단계
2. 프로토콜 스택이 소켓 한개 분량의 메모리 영역을 확보하여 제어 정보 기록
3. 소켓이 만들어지면 소켓의 디스크립터(소켓 식별번호 같은 것)를 애플리케이션에 송신(함수값 리턴)
4. 디스크립터 수신한 애플리케이션은 이후 프로토콜 스택에 데이터 송수신 동작을 의뢰할 때 디스크립터 통지

- 3-way handshake 란
  - TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish) 하는 과정입니다.
    1. Client > Server : SYN
       - 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 되는 것이다.
    2. Server > Client : SYN ACK
       - 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 클라이언트가 다시 ACK으로 응답하기를 기다린다. 이때 서버는 SYN_RECEIVED 상태가 된다.
    3. Client > Server : ACK
       - 클라이언트는 서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 서버 상태가 ESTABLISHED 이다.
- 4-way handshake 란
  - 3-Way handshake는 TCP의 연결을 초기화 할 때 사용한다면, 4-Way handshake는 세션을 종료하기 위해 수행되는 절차입니다
    1. Client > Server : FIN
       - 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.
    2. Server > Client : ACK
       - 서버는 일단 확인메시지를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 TIME_WAIT상태다.
    3. Server > Client : FIN
       - 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.
    4. Client > Server : ACK
       - 클라이언트는 확인했다는 메시지를 보낸다.

- TCP의 연결 설정 과정(3 way handshake) 와 연결 종료 과정(4 way handshake)가 차이나는 이유?
  * Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.

## Story 03. 데이터를 송ㆍ수신한다

### 3-1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

- 접속 완료 후 애플리케이션이 송신데이터를 프로토콜 스택에 건내주면서 시작
- 송신용 버퍼 메모리에 일단 저장하고 일정 시간 혹은 일정 데이터를 저장한 후 송신

### 3-2. 데이터가 클 때는 분할하여 보낸다

- 만약 보내는 데이터가 MSS를 초과하게 되면 이 때는 분할후 패킷화하여 보내게 된다.

### 3-3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다

![img](https://github.com/ambosing/PlayGround/blob/master/Img/Network/Sequence%20Number%20and%20ACK.jpg?raw=true)

- 데이터가 커서 분할하여 보낼 때, 데이터의 누락을 막기 위한 바이트 숫자가 난수로 생성되며 이것이 **시퀀스 번호**
- 수신 측에서는 이 번호를 하나하나 다시 조립하여 정보를 받음. 

### 3-4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

- 타임 아웃 : ACK 번호가 돌아오는 것을 기다리는 시간
- 네트워크가 혼잡하여 정체가 일어나면 ACK 번호가 돌아오는 것이 지연되기 때문에 타임 아웃 값을 적당한 값으로 설정
- 그래서 TCP는 대기 시간을 동적으로 변경하는 방법을 사용
- 그 방법은 AcK가 돌아오는 시간을 계측해두고 ACK가 지연되면 대기 시간도 늘리고 빨리 오면 대기 시간을 짧게 설정

### 3-5. 윈도우 제어 방식으로 ACK 번호를 관리한다



### 3-6. ACK 번호와 윈도우를 합승한다

![img](https://github.com/ambosing/PlayGround/blob/master/Img/Network/Control%20Window%20and%20Receive%20Memory.jpg?raw=true)

- 위의 그림과 같이 수신측은 수신 버퍼에 데이터를 임시 보관하고 수신 처리를 진행. 그리고 수신 처리가 끝나고 수신 버퍼에 빈 부분이 생기면 그 분량만큼 수신할 수 있는 데이터 양을 늘리므로 TCP 헤더의 윈도우 필드에서 이를 송신측에 알림.
- 이렇게 해서 수신측의 버퍼를 초과하여 데이터를 보내는 일이 없어짐.
- 윈도우 사이즈 : 수신 가능한 데이터 양의 최댓값
- 윈도우와 ACK를 같이 통지하게 되면 복수의 AcK 번호 통지가 연속해서 일어난 경우에도 패킷의 수를 줄일 수 있음.

### 3-7. HTTP 응답 메시지를 수신한다

- HTTP 리퀘스트에 대한 응답이 웹서버로부터 도착하면 read를 경유해 프로토콜 스택에 제어가 넘어가게 되고, 프로토콜 스택이 움직이기 시작
- 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 어플리케이션에게 건내줌. 이 때 응답 메시지가 돌아올 때 까지 시간이 걸려 수신 버퍼에 데이터가 들어가지 않는다면 더이상 작업 진행 x
- 그래서 프로토콜 스택은 애플리케이션에게 데이터를 추출하여 건내주는 작업을 잠시 보류
- 서버에서 응답 메시지의 패킷이 도착했을 때, 데이터를 수신하여 애플리케이션에게 건내주는 작업 재개

## Story 04. 서버에서 연결을 끊어 소켓을 말소한다

### 4-1. 데이터 보내기를 완료했을 때 연결을 끊는다

![img](https://github.com/ambosing/PlayGround/blob/master/Img/Network/4-Way%20HandShaking.PNG?raw=true)

1. 연결이 되어있는 상태에서 연결을 종료하고자 하는 client는 TCP Header의 flags 필드의 FIN을 1로 세팅하여 전송하고 소켓을 FIN_WAIT_1로 변경
2. FIN을 받은 server는 CLOSER_WAIT 상태로 변경되며 FIN에 대응 되는 ACK 전송
3. ACK 전소을 받은 client는 FIN_WAIT_2 상태로 변경되며 server의 FIN을 기다림
4. Server는 연결 종료를 위해 FIN 패킷을 client에게 전송하며 소켓을 LAST_ACK 상태로 변경
5. FIN을 받은 Client는 TIME_WAIT 상태로 변경되며 FIN에 대응되는 ACK를 Server에 전송함
6. ACK를 받은 Server는 소켓을 Closed로 변경
7. 시간이 경과하면 Client도 소켓을 Closed로 변경

### 4-2. 소켓을 말소한다

- 클라이언트와 서버간 연결 끊기 이후 잠시 대기했다가 소켓을 말소
- 이유: 오동작을 막기 위함. 만약 클라이언트로부터 ACK를 받지 않은 서버가 FIN을 다시 보냈을 경우, 클라이언트 측의 소켓이 이미 말소가 되어있고, 클라이언트 측에 말소 되었던 소켓과 같은 포트번호가 만들어졌다면, 그것은 이전 연결과 상관없는 소켓. 하지만 제어 정보에 의해서 새로 만들어진 소켓에 FIN 헤더를 가진 패킷이 도착하게 되고, 새로 만들어진 소켓이 연결 끊기 동작에 들어감. 이러한 것을 막기 위해 대기시간을 가짐

### 4-3. 데이터 송ㆍ수신 동작을 정리한다

![img](https://github.com/ambosing/PlayGround/blob/master/Img/Network/All%20TCP%20Communication.%20jpg.jpg?raw=true)

1. 소켓을 작성하고 접속 대기 상태

2. 3-Way HandShaking을 통해 접속 동작을 실행

3. 웹의 데이터 송수신 단계에서 클라이언트가 리퀘스트 메시지를 보내는 것부터 시작

4. TCP는 이것을 MSS, MTU, 타이머등을 고려해서 적당한 크기로 분할 후 TCP 헤더를 맨 앞에 부가하여 서버에 보냄

5. 메시지가 서버에 도착하면 ACK를 클라이언트에 보냄.(그 다음은 반대)

6. 이렇게 클라이언트와 서버가 ACK와 데이터를 주고받는 것을 반복

7. 클라이언트가 데이터 보내기를 완료하면 데아터 송수신 동작이 끝나므로 연결 끊기 동작에 들어감.

8. 4-Way HandShaking을 통해 접속 끊기 단계로 들어감.

## Story 05. IP와 이더넷의 패킷 송ㆍ수신 동작

### 5-1. 패킷의 기본

![img](https://github.com/ambosing/PlayGround/blob/master/Img/Network/Packet.jpg?raw=true)

- 패킷은 '헤더'와 '데이터', 이 두 부분으로 구성
- 헤더에는 수신처를 나타내는 주소 등의 제어 정보
- 데이터에는 수신자가 보내고자 하는 내용

### 5-2. 패킷 송ㆍ수신 동작의 개요

- IP 헤더는 IP프로토콜에 규정된 IP주소로,  목적지까지 패킷을 전달 할때 사용되는 제어 정보
- MAC 헤더는 MAC 주소로, 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보

![img](https://github.com/ambosing/PlayGround/blob/master/Img/Network/All%20Packet%20Communication.jpg?raw=true)

- 요약

`1.` TCP 담당 부분이 IP 담당 부분에 패킷 송신을 의뢰.

`2.` 의뢰할 때 TCP 담당 부분은 데이터의 조각에 TCP 헤더를 부가한 것을 IP 담당 부분에게 건내줌.

`3.` 이 이뢰를 받은 IP 담당 부분은 TCP 헤더 앞에 제어 정보를 기록한 IP 헤더와 MAC 헤더를 부가.

`4.` IP에서 만든 패킷을 LAN 어댑터(이더넷)에 건내줌.

`5.` 건네 받은 데이터는 이진 디지털 데이터로 변환되고 LAN 어댑터에 의해 전기나 빛의 신호 상태로 바뀌어 케이블에 송출.

`6.` 신호는 허브나 라우터 등의 중계 장치에 도착하고, 중계 장치가 상개가 있는 곳까지 패킷을 전달.

### 5-3. 수신처 IP 주소를 기록한 IP 헤더를 만든다

- 가장 중요한 필드는 패킷을 어디로 전달하는지 나타내는 수신처 IP주소 
- 수신처 IP 주소는 TCP 담당 부분에서 IP 주소 통지. 웹 서버의 IP를 애플리케이션에 통지하게 되고 그것을 TCP 담당 부분이 IP 담당 부분에 통지하는 것.
- 송신처 IP 주소는 PC의 할당된 IP 주소라고 생각하면 되는데, 더 정확히는 LAN 어댑터에 할당된 IP 주소로 만약 PC에 LAN 어댑터가 여러개 존재하는 경우, 여러 개의 송신처 IP 주소가 존재.

### 5-4. 이더넷용 MAC 헤더를 만든다

- MAC 헤더는 이더넷에서 사용하는 헤더이며 송, 수신처 MAC 주소와 이더 타입이라는 필드가 여기에 해당됨.
- 이더넷에서는 IP로 중계하지 않고, MAC 헤더를 제어 정보로 사용.

`수신처 MAC 주소` : 패킷을 전달하는 상대의 MAC 주소. LAN에서의 패킷 배송은 이 주소를 바탕으로 수행됨

`송신처 MAC 주소` : 패킷을 송신한 측의 MAC 주소. 패킷을 받았을 때 이 값에 따라 누가 보냈는지 판단.

`이더 타입` : IP 헤더의 프로토콜 번호와 비슷한 것. IP의 경우 IP 헤더 뒤에 이어지는 것이 패킷의 내용물이 되고 내용물이 어디에서 의뢰되었는지를 프로토콜 번호로 나타내는데, 이더넷은 이더 타입까지가 MAC 헤더이며 그 뒤에 내용이 패킷의 내용물.

### 5-5. ARP로 수신처 라우터의 MAC 주소를 조사한다

- ARP로 수신처 mac 주소를 얻어 오는 것.
- 동작 원리는 이더넷에 연결되어 있는 전원에게 브로드캐스트를 이용하여 ARP 패킷을 보낸다.

### 5-6. 이더넷의 기본

### 5-7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다

### 5-8. 패킷에 3개의 제어용 데이터를 추가한다

### 5-9. 허브를 향해 패킷을 송신한다

## Story 06. UDP 프로토콜을 이용한 송ㆍ수신 동작

### 6-1. 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다

### 6-2. 제어용 짧은 데이터

### 6-3. 음성 및 동영상 데이터