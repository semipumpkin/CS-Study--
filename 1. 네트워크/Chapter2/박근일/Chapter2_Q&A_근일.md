# Chapter2 Q&A



## 1. OSI 7계층과 TCP/IP 4계층에 대해 설명하시오



 OSI 7계층은 물리 - 링크 - 네트워크 - 트랜스포트 - 세션 - 표현 - 응용

 TCP/IP 계층은 네트워크 액세스 - 인터넷 - 전송 - 응용

데이터 송수신에 있어 각 부분에서 하는 역할에 따라 이를 구분하여 설명하는 방식이다.



## 2. TCP의 접속과 접속해제에 대해 설명하시오



**3-Handshaking**

: TCP에 쓰이는 연결 설정
\- SYN/SYC : 통신 요청 데이터

\- ACK : 응답 데이터
\- SYN_RCV : 통신 요청 받음

 

**4-Handshaking**

|      | **Client 상태** | **전송 데이터** | **Server 상태** |
| ---- | --------------- | --------------- | --------------- |
| 1    | CLOSE           | # 연결 X        | LISTEN          |
| 2    | CLOSE           | --SYN->         | LISTEN          |
| 3    | CLOSE           |                 | **SYN_RCV**     |
| 4    | CLOSE           | <-ACK+SYN--     | SYN_RCV         |
| 5    | **ESTABLISHED** | --ACK->         | SYN_RCV         |
| 6    | ESTABLISHED     | # 연결 성공     | **ESTABLISHED** |

|      | **Client 상태** | **전송 데이터** | **Server 상태** | **전송 데이터** | **애플리케이션 상태** |
| ---- | --------------- | --------------- | --------------- | --------------- | --------------------- |
| 1    | ESTABLISHED     | # 연결 중       | ESTABLISHED     |                 | # 프로세스 진행       |
| 2    | **FIN_WAIT_1**  | --FIN->         | ESTABLISHED     |                 | -                     |
| 3    | FIN_WAIT_1      | <-ACK--         | **CLOSE_WAIT**  |                 | -                     |
| 4    | **FIN_WAIT_2**  |                 | CLOSE_WAIT      | --CLOSE()->     | # 프로세스 종료       |
| 5    | FIN_WAIT_2      | <-FIN--         | **LAST_ACK**    |                 |                       |
| 6    | **TIME_WAIT**   | --ACK->         | LAST_ACK        |                 |                       |
| 7    | CLOSED          | # 연결 X        | **CLOSED**      |                 |                       |



**. 비정상 종료**

\- CLOSE_WAIT 상태 : 애플리케이션에서 close()를 처리해주지 못하면, TCP 포트는 CLOSE_WAIT 상태로 계속 기다리게 된다. CLOSE_WAIT 상태가 statement에 많아지게 되면, Hang이 걸려 더는 연결을 하지 못하는 경우가 발생. 여러 상황에 따라 close() 처리를 잘 해 줘야 함
\- FIN_WAIT_1 상태 : 상대방 측에 연결 종료를 요청했는데 ACK를 받지 못한 상태로 기다리는 것. 네트워크 및 방화벽의 문제일 수 있음 TIME OUT이 되면 자동으로 닫음

\- FIN_WAIT_2 상태 : 클라이언트가 서버에 종료를 요청한 후 서버에서 ACK를 받았지만, FIN 패킷 을 받지 못하고 기다리고 있는 상태. 서버 측에서 CLOSE를 처리하지 못하는 경우. TIME OUT이 되 면 스스로 CLOSED 함

 

**. 네 번째 줄에서, 클라이언트가 서버가 보낸 ACK+SYC를 받지 못하면?**

A. 두 번째 줄에서 클라이언트는 서버로 SYC를 보내고 시간을 잰다. Timeout이 되기 전까지 ACK+SYC가 오지 않으면, 다시 SYC를 보내고 ACK+SYC 수신을 대기한다.

 

**. 서버가 마지막에 FIN을 보내는 이유?**

서버가 아직 클라이언트에 보낼 데이터가 남아있을 경우 데이터를 다 전송하지도 못한 채 클라이언트 에서 포트를 닫아버리게 되므로 서버 또한 종료될 준비가 되었다는 의미로 FIN을 보냄

 

**. 클라이언트가 마지막에 ACK를 굳이 보내는 이유?**

서버가 보낸 FIN을 클라이언트가 받지 못하면 클라이언트는 FIN_WAIT_2 상태로 종료가 되지 못한 채 계속 기다려야 한다. 하지만 서버는 이미 포트를 닫고 더는 응답을 하지 않는 상태이기에 클라이 언트는 불필요한 자원을 소모할 수 있음

 

**. HTTPS 환경에서의 3-H**

\- Client -> Server : SSL정보 및 암호화방식, 무작위 바이트 문자열(A)
\- Server -> Client : 인증서, 무작위 바이트 문자열(B)
\- Client가 CA에 인증서 목록에 있는지 확인 후 있다면 공개키 받음
\- Client -> Server : 무작위 바이트 문자열 A와 B를 조합, 공개키로 암호화하여 전송
\- Server에서 비밀키로 받은 무작위 바이트 문자열 조합을 복호화, 이것으로 session key를 만듦 - 해당 session key를 가지고 암호화한 데이터를 주고받음



## 3. IP 주소와 MAC 주소의 차이점



 IP주소는 네트워크를 찾아가기 위한 주소이며 MAC 주소는 네트워크 내의 각 컴퓨터의 주소를 의미한다.



## 4. TCP와 UDP의 차이점



**TCP**
: 연결지향형 전송규약

- 흐름 중심 프로토콜, 통신을 주고받는 것을 중요시함

- 중간에 패킷이 손실되는 경우 재전송을 통해(SYN-ACK handshaking) 신뢰성을 보장함(느림) - 대부분의 통신에서 사용됨, 특히 파일이나 데이터 전송 시에 사용

- 데이터 경계 구분이 없음 (바이트 스트림 서비스)

 

**UDP**

: 비연결지향형 전송규약

- 데이터 중심 프로토콜, 주고받는 통신보다 데이터를 일방적으로 보내는 것을 중요시함 - 데이터 전송의 신뢰성 보장 X, (빠름)
- P2P, 스트리밍, 전화에 사용



| **TCP**                                                      | **UDP**                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 연결지향형 세그먼트 순서 보장, 느림 HTTP, 메일, 파일 헤더(20바이트) 추가하여 IP로 : 포트번호, 순서번호, 인정 번호, 제어 비트 | 비연결지향형 데이터그램 순서 보장 X, 빠름 DNS, Broadcasting 헤더(8바이트) 추가하여 전송 : 포트번호, 데이터의 길이, 체크섬 |

 

## 5. 허브와 리피터를 비교



|        | **리피터**                                                   | **허브**                                                     |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 공통점 | -물리계층에서 전기적인 신호를 증폭시켜 전송 거리를 연장하는 장치 |                                                              |
| 차이점 | -네트워크 신호가 연결된 모든 PC에 전달되기 때문에 연결된 장치가 많을수록 부하가 심해짐 | 패킷 모니터링과 멀티 포트를 지원하여 문제가 생긴 곳을 고립시킬 수 있음 |

 

## 6. 브릿지와 스위치를 비교



|        | **브릿지**                                           | **스위치**                                                   |
| ------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| 공통점 | -데이터링크계층에서 전송 거리를 연장하는 장치        |                                                              |
| 차이점 | 소프트웨어적으로 프레임을 다시 만들어 전송해 더 느림 | 성능에 따라 L2, L3, L4, L7로 구분됨  하드웨어적으로 처리해 더 빠름 |

 

## 7. ARP (Address Resolution Protocol)와 RARP를 비교



|        | **ARP**                                       | **RARP**                      |
| ------ | --------------------------------------------- | ----------------------------- |
| 공통점 | 네트워크 계층에서 사용되는 주소 결정 프로토콜 |                               |
| 차이점 | IP 주소에서 MAC 주소를 알아냄                 | MAC 주소에서 IP 주소를 알아냄 |

\- 상대방 MAC 주소를 모를 때, IP와 브로드 캐스팅 네트워크 주소 FFFFFFFFFFFF를 가지는 ARP 패킷을 네트워크에 전송하여 이를 수신한 호스트가 자신의 MAC 주소를 반송하는 메커니즘
\- 이때 ARP 캐시라 불리는 메모리에 테이블 형태로 저장하여, 패킷을 전송할 때에 다시 사용됨

 

## 8. 데이터 송수신 관리



 TCP의 경우 데이터의 전송에 관한 신뢰성을 보장하기 때문에 데이터 패킷의 Loss를 관리하는 프로세스가 존재한다. 기본적으로 패킷을 보내고 그 패킷을 잘 받았다는 응답신호를 돌려받는 방식으로 동작한다.

 패킷을 하나씩 받고 그에 대한 응답신호를 받는 것은 비효율적임으로 여러 개를 동시에 보내고 받는데 이 크기를 **Window**라고 한다. 이 Window의 크기는 고정된 것이 아니고 컴퓨터의 사정에 따라 바뀌기 때문에 이 크기를 계속해서 관리해주기 위한 프로세스가 필요하다.



