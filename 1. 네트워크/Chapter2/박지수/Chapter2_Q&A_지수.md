# Chapter2 Q&A

박지수



### OSI 7 계층 ?

물리계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층이 있다. 물리적으로 분리 된 것이 아니라 개념적으로 구분된 것이라고 보는 것이 좋다. 

- 물리 : 이전 단계에서 전송된 데이터를 실제 빛 or 전기신호로 변환하여 전송
- 데이터 링크 : 흐름 제어, 오류 제어 가능. MAC 주소를 가진다.
- 네트워크 : 라우팅 프로토콜을 통해 데이터 전송에 필요한 최적의 경로 선택
- 전송 : 패킷 분할/ 재조립, 연결/흐름제어, 오류제어. 시퀀스 넘버를 확인하여 패킷의 송수신을 확인
- 세션 : 송수신 방식, 프로세스 사이의 대화 제어, 동기화 담당. TCP/IP 세션을 만들고 없앤다.
- 표현 : 인코딩, 포맷 변경, 암호화 등
- 응용 : 사용가자 OSI 환경에 접근할 수 있도록한다. HTTP 등



### TCP/IP 4계층?

OSI 7 계층을 단순화한 모형. `TCP` 는 전송 계층에 위치하며 네트워크 정보 전달을 통제하는 핵심 프로토콜이다. `IP`는 패킷 교환 네트워크에서 정보를 주고받는데 사용하는 정보 위주의 규약이다.

- 네트워크 계층 : MAC 주소를 참조해 장비간 데이터 송수신 (브리지, 스위치)
- 인터넷 계층 : 데이터 전송을 위한 IP 주소 지정 및 경로 지정 (라우터)
- 전송 계층 : 포트 번호로 호스트간의 연결 제어 및 자료 송수신 (게이트 웨이)
- 응용 계층 : 응용 프로그램간의 데이터 송수신, GUI



### 프로토콜 스택?

네트워크 제어용 소프트웨어로 `TCP` 또는 `UDP` 프로토콜을 사용하여 송수신을 담당하며, `IP` 프로토콜을 사용하여 패킷 송수신 동작을 제어하는 부분이 있다.



### 소켓?

프로토콜 스택 내에서 데이터를 송수신 하기 위한 제어정보(송수신 IP 주소, 포트번호, 통신 상태 등등)가 기록된다.  이러한 제어정보의 총체 or 제어정보를 기록한 메모리 영역을 소켓이라 한다. `Sockect` 라이브러리에서 `socket()`을 입력하면 소켓이 생성된다.



### 접속?

소켓이 생성된 후 `connect()`를 입력하면 접속 동작이 시작된다. 그러면 패킷의 헤더가 만들어진다. 헤더는 실제 전송 데이터 앞쪽에 붙는 제어 정보로 TCP 헤더, IP 헤더가 있다. 접속 동작을 시작하면 헤더의 컨트롤 비트인 `SYN`을 1로 만들며, 이는 접속을 개시한다는 것을 의미한다. `SYN`을 1로 만든 패킷을 수신측으로 보내면 이를 받은 서버측 소켓도 `SYN`을 1로 만든다. 이후, 이 패킷을 잘~ 받았다는 의미로 응답을 돌려보내는데, 이때 `ACK` 라는 컨트롤 비트를 1로 만든다. 클라이언트도 잘~ 받았다는 의미로 위와 같이 동작하고, 서버가 `ACK`가 1인 패킷을 받으면 비로소 접속이 완료된다.

1. 클 --> 서버 : **SYN 1** ; 접속 할거임

2. 서버 -- > 클 : **SYN 1**, **ACK 1**; 너 접속하려고? OK 알겠슴, 패킷 잘 받았다고 말해야 클라이언트가 알거임

3. 클 --> 서버 : **ACK 1**; 아 ㅇㅋ 잘 받았구나, 그럼 나도 너가 보낸 답신 잘 받았다고 알려줘야겠다.

----> 클라이언트, 서버 모두 SYN 1, ACK 1로 저장 완료! `접속 완료`



### 3-way handshake

위 접속 동작이 3번 왔다갔다 하는데, 이를 말그래도 3번 악수한다고 표현한 것. `TCP` 프로토콜의 접속동작이다. 단계마다 잘 받았다는 답신 (ACK 1)이 와서 중간에 패킷이 유실되는것을 빠르게 확인 할수 있다. 그렇기 때문에 대량의 소켓중 특정 하나가 유실되거나 누락된 경우, 그것만 다시 보내면 된다.



### MTU MSS

- MTU : 패킷 하나로 운반할 수 있는 데이터의 최대길이, 이더넷에서는 보통 1500바이트
- MSS : 실제 데이터가 저장되는 길이로, 헤더를 제외한 데이터의 최대 길이(TCP데이터의 최대 길이)이다. 데이터가 MSS 이하라면 패킷을 분할할 필요가 없다.



### 분할한 데이터 송수신을 어떻게 하는가?

TCP 헤더에는 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇번째 바이트에 해당하는지를 세어둔 `시퀀스 번호`가 저장된다.수신측은 이전 데이터까지 합쳐서 어디까지 수신한지를 계산하고, 그 값을 TCP 헤더의 `ACK 번호`에 기록하여 송신측에 알려준다. 이 ACK 번호를 되돌려주는 동작은 `수신확인응답`이라고 부르며, 이것을 통해 상대가 어디까지 수신했는지를 파악한다. 시퀀스 번호는 초기값을 랜덤하게 지정하여 외부 공격으로부터 데이터를 보호한다. 단, 이를 수신측에도 알리지 않으면 송수신이 불가하기 때문에 처음 접속 동작에 `SYN`을 1로 할때 시퀀스 번호에도 값을 설정하여 초기값을 알려준다.



### ACK 번호의 대기 시간 조정 방법

`ACK 번호`가 돌아오는 것을 기다리는 대기 시간을 `타임아웃 값`이라고 한다. 데이터 송신 동작을 실행하고 있을 때 항상 `ACK 번호`가 돌아오는 시간을 계측해두고, 지연되면 이에 대응하여 대기시간도 늘린다. 반대로 곧바로 돌아오면 대기시간을 짧게 설정한다. 하지만 컴퓨터의 시간계측은 정밀도가 낮으므로, 대기의 최소시간은 일반적으로 0.5초~1초로 설정되어 있다.



### ACK 번호를 효율적으로 관리하는 방법

한개의 패킷을 보내고 `ACK 번호`가 돌아오기까지 기다리는것은 비효율적이므로, TCP는 `윈도우 제어 방식`을 따른다. 이는 수신측에서 송신측에 수신가능한 데이터 양을 통지하여, 이를 넘지 않게 송신 동작을 하는 것이다. 수신측은 버퍼 데이터에 데이터를 임시보관하고, 수신처리 한다. 처리가 끝나면 버퍼가 비고, 그만큼 수신할 수 있는 데이터양을 늘리므로, 이를 TCP 헤더의 `윈도우 필드`에서 알린다. 수신 가능한 데이터양의 최대값을 `윈도우 사이즈`라고 부르며, TCP를 정밀히 조정하는 매개변수의 하나이다. 그리고이 `윈도우 사이즈`는 고정된 상수가 아니라 패킷 전송속도에 따라 달라지는 값으로, 패킷의 전송개수를 늘리면서 윈도우 사이즈를 늘려가다가, 버퍼의 빈공간이 줄거나, 누락된 패킷이 있으면 `윈도우 사이즈`를 급격하게 낮추고 다시 늘리기를 반복한다.



### 4-way handshake (접속 해제, 소켓 말소)

소켓 라이브러리의 `close` 명령어를 입력한 후 수행하는 동작이다. 

1. 클라이언트 -> 서버 : `FIN` 1 (모든 데이터 송신이 완료되었다는 것을 의미하며, 접속 해지를 개시)
2. 서버 -> 클라이언트 : `ACK` 1 (클라이언트가 보낸 `FIN` 1이 저장된 패킷을 받았다는 것을 의미)
3. 서버 -> 클라이언트 : `FIN` 1 (모든 데이터 수신이 완료되었다는 것을 의미)
4. 클라이언트 -> 서버 : `ACK` 1 (서버가 보낸 `FIN` 1이 저장된 패킷을 받았다는 것을 의미, 접속 종료)

소켓 말소는 위작업이 완료된 후 바로 수행되지 않고, 몇분정도 지난후에 말소된다. 이유는 위 작업에서 누락된 데이터가 있거나, 소켓이 제거된 후에 `FIN`을 받으면 새로운 소켓이 시작도 하기전에 끝날 수도 있다. 이를 방지하려고 소켓 말소 전에 텀을 둔다.



### 이더넷, IP

- **이더넷** : ethernet은 OSI 모델을 기준에서 데이터 링크 계층을 담당합니다. ethernet은 물리 계층과 데이터 링크 계층의 통신 회선의 접근 제어를 정의하는 IEEE 표준으로 IEEE 802.3 규약이 대표적입니다. ethernet은 빛의 매질로 생각했던 에테리(Ether)에서 유래하였고 근거리 통신망(LAN)에 사용하기 위해 개발한 기술입니다. 지금은 IEEE 802.3 규약으로 표준화하였고 WAN과 LAN에서 모두 활용하고 있습니다. ethernet은 네트워크 장치마다 부여하는 mac 주소를 가지고 실제 물리 회선을 통해 주고 프레임을 주고 받는 것을 담당합니다.
- **IP** : 인터넷 프로토콜(IP)은 TCP/IP 통신에서 네트워크 계층을 담당하고 있습니다. 이는 TCP/IP 통신에서 네트워크 엔터티를 구분하는 주소를 결정하는 역할을 담당함을 의미합니다.

데이터 송수신의 정확한 위치를 알기 위해서는 2가지 주소가 필요한데 IP주소, MAC주소(이더넷 주소, 고유 번호로 통신기기마다 다르다)이다. `라우터` 는 IP 주소를 확인하여 송수신지를 확인하며, `허브`는 이더넷 규칙에 따라 패킷을 운반한다. 또한, 이 송수신 주소는 실제 최종 목적지에 대한 주소가 있지만, 실제보내질때 바로 다음에 가야하는 주소는 아니다. 예를 들어 1~5로 연결된 노드가 있다고 하면 최종 목적지는 5이지만, 실제 전송은 1->2, 2->3 이런식으로 중계되면 그때그때 전달될때는 바로 다음에 갈 목적지에 대한 정보만 가지고 간다.



### 데이터 송수신의 실체?

패킷 = MAC헤더 + IP 헤더 + 실제데이터 이렇게 데이터를 분할하고 묶는것을 캡슐화라고 한다. 이는 디지털 데이터 이기때문에 실제 랜선, 전봇대 등등을 통해 실제 전송될 때는 빛 or 전기 신호로 변경되어 보내진다. 최종적으로 수신처에 이러한 0과 1로 이루어진 비트가 들어오면, 수신처의 LAN 어댑터가 이를 다시 디지털 데이터의 모습으로 변환하여 IP 담당부 -> TCP 담당부 -> 어플리케이션 or 브라우저로 이동하는 방식이다.



### 리피터 허브, 스위칭 허브

이더넷의 종류이다. 과거에는 리피터 허브를 사용하였는데, 현재는 대부분 스위칭 허브를 사용하고 있다. 

- **리피터 허브** 는 중앙에 이더넷이 데이터를 수신하면, 이와 연결된 모든 기기에 신호를 보낸다. 그래서, 그중에 송수신 정보가 일치하는 패킷을 받은 기기만 동작을 수행하는 식이다. 왜냐하면 리피터 허브는 각 기기의 MAC주소를 모르기 때문에 일단 다 보내봐서 때려맞추는 느낌이다.
- **스위칭 허브** 는 각 기기들의 `MAC 주소`를 이미 알고 있다. 그래서 수신받은 데이터를 조사하여 이에 맞는 주소로 원하는 기기에만 데이터를 보낸다.



### MAC 회로의 역할

 `프리앰블`, `스타트 프레임 딜리미터` , `프레임 체크 시퀀스(FCS)` 이 3가지는 패킷을 보낼때 정확한 데이터를 유지하고, 오류를 검출하기 위해 사용된다.

- **프리앰블** : 패킷을 읽기 시작하는 시점을 정확히 하기 위해 부가하는 데이터로, 1010이 번갈아 나타나는 56비트가 이어진 것이다. 이를 신호로 바꾸면 일정한 파형이 되기때문에, 이 파형과 클록 신호를 합쳐 전기신호를 정확히 읽을 수 있게한다.
- **스타트 프레임 딜리미터(SFD)** : 패킷의 시작을 나타내는 표시
- **FCS** :  패킷 운반도중 파형이 흐트러져 데이터가 변한 경우, 이를 검출하기 위해 패킷의 맨뒤에 부가하는 32비트(패킷 내용을 CRC 라는 계산식으로 계산한 것)이다.



### 반이중 모드, 전이중 모드

반이중 모드는 리피터 허브를 사용한 경우, 전이중 모드는 스위칭 허브를 사용한 경우이다.

- **반이중 모드** : 케이블에 다른 기기의 신호가 흐르는지 확인, 끝날때까지 기다렸다가 송신
  - **PHY(MAU)** 회로는 MAC 회로가 송신한 신호의 형식을 변환하기 위한 변환회로이다
  - **재밍** : 반이중 모드에서 충돌이 발생한 경우, 이를 다른 기기에 알리기 위한 신호
  - 반이중 모드는 충돌할때마다 대기시간을 2배씩 늘리고, 재전송한다. 10번째까지 보냈는데 해결되지 않으면 오류로 판단한다.
- **전이중모드** : 송수신을 동시에 실행하면서 충돌이 일어나지 않는다.



### 패킷을 받아서 본체에 알릴때, 본체가 다른 작업을 하고 있다면?

데이터가 리피터, MAC회로를 지나 LAN 어댑터에 도달했는데, 본체가 다른일을 진행중이라면 `인터럽트` 라는 구조를 이용한다. 말그대로 방해(끼어드는 것)이다. `LAN 드라이버`가 확장 버스 슬론 부분에 있는 인터럽트 신호선에 신호를 보내면, 인터럽트 컨트롤러를 통해 CPU에 전해지고, 이를 받으면 CPU는 하고 있던 작업을 일시적으로 보류하고 인터럽트 처리용 프로그램쪽으로 동작한다.  여기서 `LAN 드라이버`가 호출되면 `LAN 어댑터`를 제어하여 송수신 동작을 실행한다.



### `LAN 드라이버` 에서 넘어온 패킷은 어디로?

우선 TCP/IP의 프로토콜 스택으로 패킷이 넘어오고 IP주소를 확인하여 정상수신이 맞는지 확인한다. 아니라면 `ICMP` 라는 메시지를 사용하여 오류를 통지한다. 패킷은 일반적으로 분할되어 들어오기 때문에, 원래 패킷으로 되돌려야한다. 분할된 패킷은 IP헤더에 있는 `플래그`라는 할목으로 분할 여부를 알수 있다. 분할된 것이면 IP 담당부분 내의 메모리에 일시보관하고, `패킷 ID`(IP 헤더에 있음)가 같은 모든 패킷이 도착하기를 기다린다. 또한 `프래그먼트 오프셋` 이라는 항목에는 패킷이 원해 패킷의 어느 위치에 있었는지를 나타내는 정보가 들어있다. 이들을 바탕으로 패킷을 원해 모습으로 되돌리는 `리어셈블링(reassembling)`을 한다.



### TCP와 UDP의 차이점?

위에서 TCP는 접속 시작과 끝 부분에서 3 way, 4 way handshake 등으로 접속 동작의 단계가 있다. 또한, 패킷을 하나 받을 때마다 받았다고 `ACK`를 1로 하여 답신한다. 큰 데이터에서 일부 패킷이 누락된 경우 그 하나의 패킷이 누락된 것을 파악하고 재송신 하는 경우에 유용하다. 하지만 작은 데이터나, 하나의 단일 데이터를 보내는데 이러한 복잡한 동작이 필요하지는 않을 것이다. TCP는 정확하고, 안전하게 패킷을 보내지만, 빠르지는 않다.

그래서 수정 송신이 필요없는 데이터(보내기만 하는), 제어용 짧은 데이터, 음성 및 영상 데이터들은 UDP 프로토콜을 사용하기도 한다. UDP는 TCP와 다르게 한번에 모든 데이터를 전부 보낸뒤에 수신응답을 받는다. 그래서 대량의 데이터를 주고 받는 다면, 한개의 패킷이 잘못되었어도 전체를 다시 보내야 해서 비효율적이지만 위에서 언급한 경우에서는 오히려 효율적이다.