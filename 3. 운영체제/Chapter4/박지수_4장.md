> 운영체제와 정보기술의 원리(반효정 저)



📙 ***chap4. 프로그램 구조와 실행***





## 1. 프로그램의 구조와 인터럽트

- 프로그램의 주소 영역은 크게 아래 3가지로 구분된다.
  - 코드(code) 영역 : 코드가 CPU에서 수행 가능한 기계 명령어(machine instruction) 형태로 저장되는 부분
  - 데이터(data) 영역 : 전역 변수등 데이터를 저장하는 부분
  - 스택(stack) : 함수 콜 스택에서의 스택



### 프로그램의 실행 순서

메인 함수가 다른 함수를 호출하면, CPU가 그 다른 함수를 실행한다. 콜 스택에 함수 호출이 쌓이는 방식으로, 이때 스택에 돌아가야하는 복귀 주소가 담겨있다.



### 인터럽트 동작 원리

함수의 호출과 동일하며 CPU가 기존에 하던 작업을 스택에 둔 채로 인터럽트를 처리 하기 위한 인터럽트 처리루틴으로 넘어가 새로운 함수를 실행한다. 인터럽트 처리가 완료되면, 그 호출을 콜 스택에서 제거 하고, 기존에 하던 작업으로 돌아온다.

#### 📌차이점

- 일반적으로 프로그램 내에서 발생되는 함수호출에 필요한 복귀 주소는 **각 프로그램의 스택 영역**에 보관한다.

- 하지만 인터럽트때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 **프로세스 제어 블록**(어느 부분까지 실행되었었는지 저장)에 저장된다.

<br/>



## 2. 컴퓨터 시스템의 작동 개요

### 프로그램 카운터(Program Counter)

- CPU가 수행해야할 메모리 주소를 담고있는 레지스터
- CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령어를 처리한다.
- 반복문이나 함수호출이 없는한 항상 바로 다음 명령어를 가리키게 되어 순차적 수행이 가능하다.



### 컴퓨터 시스템의 구성

- 하드웨어 : CPU, 메모리
- 입출력 장치 : 모니터 키보드 등등
- 입출력 컨트롤러 :  입출력 장치를 전담하는 작은 CPU
- 로컬 버퍼 : 입출력 장치를 전담하는 작은 메모리



### 메모리

- 사용자 프로그램과 운영체제가 같이 올라가서 수행된다.
- 커널 모드(kernel mode) : 프로그램 카운터가 운영체제가 존재하는 메모리를 가리키는 경우. 즉, 운영체제 코드를 수행중인 경우
- 사용자 모드(user mode) : 위와 반대



### CPU가 수행하는 명령

- 일반명령
  - 메모리에서 자료를 읽어와 CPU에서 연산을 하고, 그 결과를 메모르에 쓰는 명령
  - 모든 프로그램이 수행할 수 있음
- 특권 명령
  - 보안이 필요한 명령으로, 입출력 장치, 타이머등 각종 장치에서 접근하는 명령
  - 운영체제만이 수행할 수 있음
- 모드 비트(mode bit) : 위 두 명령어의 실행 가능성을 체크하긴 위한 CPU내 메모리 (3장 참고)



### 시스템 콜

- 사용자 프로그램 실행 중 특권 명령이 필요한 경우, 운영체제에 특권명령 대행을 요청 하는 것
- 시스템 콜을 하면 사용자 영역이 아닌 커널 영역에서 코드를 처리 한다.
- 요청을 받은 장치는 해당 장치의 로컬 버퍼의 연산의 결과를 저장하고, CPU에 인터럽트를 방생시켜 CPU에 알린다.



### CPU가 인터럽트를 확인하는 방법

- CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 확인하느라, 주변 장치 상태를 모른다.
- 그래서  CPU는 매번 명령을 수행한 직후 인터럽트 라인(인터럽트를 방생시키기 위한 세팅)을 체크한다.

<br/>



## 3. 프로그램의 실행

### 프로그램 실행의 의미

1. 디스크에 존재하던 실행 파일이 메모리에 적재 된다는 의미
2. 프로그램이 CPU를 할당받고 명령(instruction)을 수행하고 있는 상태라는 의미



### 커널

#### 데이터 영역

- 시스템 내 모든 자원을 관리하기 위한 자료구조를 각각 유지하고 있는 영역
- 프로세스 : 현재 수행중이 프로그램
- PCB : 각 프로세스의 상태, CPU의 사용정보, 메모리 사용 정보등을 유지하기 위한 자료구조



#### 스택 영역

- 일반 프로그램의 스택 영역과 동일하게 함수 호출 복귀 주소를 저장하기 위한 용도
- (차이점 📌) 사용자 프로그램 스택과 달리, 프로세스마다 별도의 스택을 두어 관리한다.
  - 프로세스가 특권명령을 수행할 때 복귀 주소가 커널 내 주소가 되기 때문에 별도의 저장공간이 필요하기 때문.
  - 커널은 일종의 공유 코드이기 때문에, 일관성 유지를 위해
- (정리) 프로그램이 자기자신 내의 코드 실행에서는 자신의 스택을 사용하고, 시스템 콜이나 인터럽트 시에는 커널 스택을 사용한다.
- (주의) 시스템 콜이나, 인터럽트 발생으로 CPU 수행 주체가 운영체제로 바뀌는 순간 복귀 정보를 스택이 아닌 PCB에 저장한다.

<br/>



## 4. 사용자 프로그램이 사용하는 함수

### 사용자 정의 함수와 라이브러리 함수

- 사용자 정의 함수 : 프로그래머 본인이 작성한 함수
- 라이브러리 함수 : 프로그래머 본인이 작성하지는 않았지만 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 경우
- 프로그램이 실행될 때 해당 프로세스의 주소 공간에 포함되며, 자신의 주소공간에 있는 스택을 사용한다.



### 커널 함수

- 운영체제 커널의 코드에 정의된 함수로 콜함수와 인터럽트 함수가 있다.
  - 콜 함수 : 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출하는 함수 ex) read(), write()
  - 인터럽트 처리 함수 : 각종 하트웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 함수
- 운영체제 커널의 주소 공간에 코드가 정의 되며, 운영 체제 내에 있는 함수를 사용자 프로그램이 호출해서 사용한다.

<br/>



## 5. 인터럽트

CPU는 매 명령어 수행 후에 인터럽트 라인 체크를 통해 인터럽트를 확인한다. 인터럽트 발생시 운영체제의 인터럽트 처리 루틴으로 이동해서 인터럽트를 처리한다. 후에 직전에 수행하던 프로세스에게 다시 CPU 제어권이 넘어간다.



### 인터럽트 처리 중 인터럽트가 발생 한 경우

- 원칙적으로는 이러한 상황이 발생하는 것을 허용하지 않는다.
  - 데이터의 일관성이 유지 되지 않는 문제
  - 이중으로 동일한 데이터를 바꾸려는 경우 원하는 동작이 되지 않음.
- 하지만 현재 인터럽트 보다 더 시급한 경우 예외로 처리한다.
  - 현재 인터럽트보다 우선순위가 높은 인터럽트 발생시 우선순위가 높은 것 먼저 처리한다.

<br/>



## 6. 시스템 콜

### 시스템 콜이란?

- 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출 하는 것. 즉, 자신의 프로그램이 아닌 다른 프로그램의 커널에 있는 함수를 호출하는 것
- 공간 자체가 다른 곳으로 이동하기 때문에 일반 함수 호출과는 차이가 있으며,  이는 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어 진다.



### 디스크 파일의 입출력

#### 동작 순서

1. 디스크 파일을 읽어와야 하는 경우 시스템 콜로 커널의 함수를 호출하게 된다.
2. 입출력 함수의 호출이 자신의 주소 공간에서 이루어질 수 없기 때문에, CPU 제어권을 운영체제에 이양한다.
3. 인터럽트 라인을 세팅한다
4. CPU가 인터럽트를 감지한다.
5. 사용자 프로그램을 멈추고 CPU를 운영체제에게 이양한다. 운영체제는 인터럽트의 내용을 파악한다.
6. 서비스 루틴으로 이동해 입출력 작업을 수행한다.
7. CPU는 디스크 컨트롤러에게 파일을 읽어오는 명령을 한다.



#### 효율성

이때 디스크 컨트롤러가 디스트에서 데이터를 읽어오는 일은 CPU의 명령 처리 속도보다 상대적으로 많은 시간이 소요된다. 따라서 CPU가 이것을 기다리는 건 비효율적인 자원 관리다. 또한, 입출력을 요청한 프로세스(A)에게 CPU제어권을 돌려줄 경우, 아직 디스크가 안읽어진 상태에서 다음 동작을 수행할 수 없으므로 바람직하지 못하다.



#### 동작 순서 이어서

8. 대부분의 경우 입출력을 요청한 다음 CPU의 제어권을 다른 프로세스(B)에게 넘긴다.
9. 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에 인터럽트를 발생시킨다
10. CPU는 B 프로세스를 잠시 멈추고 인터럽트 처리 루틴으로 넘어간다(운영체제로).
    - 이때 발생한 인터럽트는 하드웨어 인터럽트(디스크가 발생했으니까) 에 해당한다.
    - 디스크 출력 결과 -> 로컬버퍼 -> 컴퓨터 내의 메모리로 복사
11. A 프로세스는 CPU 대기열(큐)에 들어간다
12. CPU는 다시 B로 돌아간다.

<br/>



## 7. 프로세스의 두 가지 실행 상태

하나의 프로세스가 실행될때 자신의 주소 공간에 있는 코드만 실행되는 것이 아니라, 커널의 주소 공간에 있는 코드도 실행된다. (입출력을 필요로 하는 경우 등) 전자를 `사용자 모드에서의 실행 상태`, 후자를 `커널 모드에서의 실행 상태` 라고 한다. 주의할 점은 프로세스 A가 입출력을 필요로 해서 CPU의 제어권을 운영체제에 넘긴 상태라고 하더라도 프로세스 A가 실행상태라고 말한다. 다만, 이러한 상태를 구분지어 `프로세스 A가 커널 모드에서 실행 중` 이라고 한다.





































